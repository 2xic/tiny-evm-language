// First part of the dropper challenge is for us to be able to decode the function inputs
// 0000000000000000000000000000000000000000000000000000000000000040 -> First entry location
// 00000000000000000000000000000000000000000000000000000000000000a0 -> Second entry location
// 0000000000000000000000000000000000000000000000000000000000000002 -> size
// 00000000000000000000000000000000000000adc04c56bf30ac9d3c0aaf14dc -> Entry 1
// 00000000000000000000000000000000000000adc04c56bf30ac9d3c0aaf14dc -> Entry 2
// 0000000000000000000000000000000000000000000000000000000000000002 -> size
// 000000000000000000000000000000000000000000000000000000000000002a -> Entry 1
// 000000000000000000000000000000000000000000000000000000000000003e -> Entry 2


function readEntry {
    // We have no while loops, we need to recursivly call this function 

    assembly {
        // CMP that we are not at the end yet
        PUSH0;
        MLOAD;
        PUSH1 32;
        MLOAD;
        EQ;
        ISZERO;
    }

    // Only walk into this function if it's close to the top .... 
    if (stack_top_is_zero == 0){
        // Need to re-enter the function until we are done.
        assembly {
            // Load in the data ? 
            PUSH0;
            MLOAD;
            PUSH1 1;
            ADD;
            DUP1;
            PUSH0;
            MSTORE;

            PUSH1 32;
            MUL; 
            // Load in first index
            DUP1;
            PUSH1 64;
            MLOAD;
            ADD;
            CALLDATALOAD;
            // ^ should be the first entry

            // Load in the second entry 
            DUP2;
            PUSH1 96;
            MLOAD;
            ADD;
            CALLDATALOAD;
            // ^ second entry

            PUSH1 0; // retSize
            PUSH1 0; // retOffset
            PUSH1 0; // argSize
            PUSH1 0; // argOffset
            DUP7; // value
            DUP7; // address
            GAS;
            CALL;
        }
        readEntry;
    }
}


// if calldata 4 bytes == airdropETH
assembly {
    // Size of the first array will match the second one so we use that to track the location.
    PUSH0;
    PUSH1 1; // Need to start at 
    MSTORE; // Global index pointer 
            
    // Load in the first offset
    PUSH1 4;
    DUP1;
    CALLDATALOAD;
    ADD;
    PUSH1 64;
    MSTORE;    

    //  0, 32 -> indexes
    // 64, 96 -> Locations

    // Now we also load in the size poitner to slot 2
    PUSH1 36;
    CALLDATALOAD;
    PUSH1 4;
    ADD;
    PUSH1 96;
    MSTORE; 

    // Now we specify the length
    PUSH1 64;
    MLOAD;
    CALLDATALOAD;
    PUSH1 32;
    MSTORE;
};

// Call the function to read out all the entries
readEntry;

